function add(xPromise,yPromise) {
// `Promise.all([ .. ])` получает массив обещаний
// и возвращает новое обещание, ожидающее завершения
// всех обещаний в массиве
    return Promise.all( [xPromise, yPromise] )
    // при разрешении этого обещания можно взять
    // полученные значения `X` и `Y` и просуммировать их.
        .then( function(values){
    //`values` - массив сообщений из ранее разрешенных обещаний
            return values[0] + values[1];
        } );
}
// `fetchX()` и `fetchY()` возвращают обещания
// для соответствующих значений, которые могут быть готовы
// сейчас или позднее.
add( fetchX(), fetchY() )
// мы получаем обещание для суммы этих двух чисел.
// теперь сцепленный вызов `then(..)` используется для ожидания
// момента разрешения возвращенного обещания.
    .then(           // -может получать две функции:
        function(sum){ // обработка успешного выполнения
            console.log( sum ); // так гораздо проще!
        },
        function(err) {  // обработка отказа
            console.error( err ); // облом!
        }
    );


function foo(x) {
// начать выполнение операции,
// которая может занять некоторое время
// вернуть объект уведомления для события `listener`
    return listener;
}
var evt = foo( 42 );
evt.on( "completion", function(){
// теперь можно переходить к следующему шагу!
} );
evt.on( "failure", function(err){
// в `foo(..)` что-то пошло не так
} );

function foo(x) {
// начать выполнение действий, которые могут занять много времени.
// сконструировать и вернуть обещание
    return new Promise( function(resolve,reject){
        // в будущем вызвать `resolve(..)` или `reject(..)` -
        // обратные вызовы для выполнения или отказа обещания.
    } );
}
var p = foo( 42 );
bar( p );
baz( p );

//внутренняя реализация bar(..) и baz(..):
function bar(fooPromise) {
    fooPromise.then(  // прослушивать завершение `foo(..)`
        function(){
            // функция `foo(..)` завершена, перейти к задаче `bar(..)`
        },
        function(){
            // в `foo(..)` возникли какие-то проблемы
        }
    );
}
// то же для `baz(..)`


//-------Другое возможное решение выглядит так:
function bar() {
    // функция `foo(..)` определенно завершилась,
    // выполнить задачу `bar(..)`
}
function oopsBar() {
    // в `foo(..)` возникли какие-то проблемы,
    // поэтому `bar(..)` не запускается
}
// то же для `baz()` и `oopsBaz()`
var p = foo( 42 );
p.then( bar, oopsBar );
p.then( baz, oopsBaz );

var p = Promise.resolve( 21 );
var p2 = p.then( function(v){
    console.log( v ); // 21
    return v * 2;     // выполнение `p2` со значением `42`
} );
p2.then( function(v){ // сцепление `p2`
    console.log( v ); // 42
} );








